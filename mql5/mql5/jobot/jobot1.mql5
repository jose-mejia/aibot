//+------------------------------------------------------------------+
//|                                                       jobot1.mq5 |
//|                     Copyright 2025, Gemini AI Bot / Merged Logic |
//|  VERSÃO CLEAN: Foco na Tabela Quantitativa e Interface Visual    |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Gemini AI Bot"
#property version   "1.02"
#property strict

#include <Trade\Trade.mqh>
#include <Trade\PositionInfo.mqh>

//--- INPUTS ---
input group "--- ESTRATÉGIA ---"
input bool        InpUsarAC           = true;       // Usar Filtro Oscilador AC?
input int         InpPeriodoMedia     = 10;         // Período Média Móvel (SMA)
input double      InpPercentualRomp   = 0.15;       // % Rompimento da Barra Anterior

input group "--- SEGURANÇA E RISCO ---"
input double      InpVolume           = 0.0;        // Lote (0.0 = Mínimo Automático)
input int         InpMaxSpread        = 45;         // Spread Máximo (Pontos)
input int         InpSlippage         = 30;         // Slippage (Pontos)
input int         InpSegundosBloqueio = 5;          // Estabilização de vela (Segundos)
input double      InpMetaFinanceira   = 50.00;      // Meta de Lucro Diária ($)
input double      InpDrawdownMax      = 100.00;     // Perda Máxima Diária ($)
input int         InpMaxOperacoes     = 100;        // Máximo de Operações/Dia

input group "--- NOTÍCIAS ---"
input string      InpHoraNoticia      = "10:30";    // Horário Ref. (Backup)
input int         InpMinAntes         = 5;          // Minutos Antes da Notícia
input int         InpMinDepois        = 5;          // Minutos Depois da Notícia

input group "--- INTERFACE VISUAL ---"
input int         InpTamanhoFonte     = 9;          // Tamanho da Fonte
input int         InpEixoX            = 30;         // Posição X (Tabela)
input int         InpEixoY            = 60;         // Posição Y (Tabela)

//--- GLOBAIS ---
CTrade          trade;
int             handleSMA = INVALID_HANDLE;
int             handleAC  = INVALID_HANDLE;
bool            g_botLigado = true;
bool            g_travaSeguranca = false;
double          g_loteFinal = 0.01;
datetime        g_horaInicioSessao;
datetime        g_ultimaVelaTS = 0;
string          g_gvName = "";

// Variáveis de Estatística Quantitativa (Tabela)
int             g_somaCC=0;
int             g_somaVC=0;
int             g_totalLinhasC=0;
int             g_totalLinhasV=0;
double          g_saldoFechado=0;
double          g_lucroAberto=0;
double          g_equityProj=0;
int             g_opsGeral=0;

// Constantes Visuais
const string    LINHA_SUP = "TH_L_SUP";
const string    LINHA_INF = "TH_L_INF";
const string    PREFIX_V  = "TH_V_";

//+------------------------------------------------------------------+
//| Inicialização (OnInit)                                           |
//+------------------------------------------------------------------+
int OnInit() {
   g_horaInicioSessao = TimeCurrent();
   g_gvName = StringFormat("Jobot1_Ops_%d", _Period);
   
   if(!TerminalInfoInteger(TERMINAL_CONNECTED)) {
      Print("ERRO CRÍTICO: Sem conexão com servidor!");
      return(INIT_FAILED);
   }

   // Persistência
   if(GlobalVariableCheck(g_gvName)) 
      g_opsGeral = (int)GlobalVariableGet(g_gvName);
   else 
      GlobalVariableSet(g_gvName, 0);

   // Normalização de Lote
   double mVol = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double sVol = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   g_loteFinal = (InpVolume <= 0.0) ? mVol : InpVolume;
   if(sVol > 0) g_loteFinal = MathFloor(g_loteFinal/sVol)*sVol;
   
   trade.SetExpertMagicNumber(999888); // Magic específico Jobot1
   trade.SetDeviationInPoints(InpSlippage);

   handleSMA = iMA(_Symbol, _Period, InpPeriodoMedia, 0, MODE_SMA, PRICE_CLOSE);
   handleAC  = iAC(_Symbol, _Period);
   
   if(handleSMA == INVALID_HANDLE || handleAC == INVALID_HANDLE) {
      Print("Erro ao criar handles de indicadores");
      return(INIT_FAILED);
   }
   
   MqlRates daily[]; 
   ArraySetAsSeries(daily, true);
   if(CopyRates(_Symbol, PERIOD_D1, 0, 1, daily) > 0) {
      ConfigurarLinhasMaster(daily[0].high, daily[0].low);
   }
   
   EventSetTimer(1); 
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Desinicialização (OnDeinit)                                      |
//+------------------------------------------------------------------+
void OnDeinit(const int reason) { 
   EventKillTimer(); 
   LimparGrafico(); 
}

//+------------------------------------------------------------------+
//| Loop Principal (OnTick)                                          |
//+------------------------------------------------------------------+
void OnTick() {
   MqlRates rates[]; 
   ArraySetAsSeries(rates, true);
   
   // Verifica se há dados suficientes (pelo menos 10 velas)
   if(CopyRates(_Symbol, _Period, 0, 10, rates) < 10) return;

   // 1. Atualizar Finanças
   CalcularFinanceiroGeral();
   g_equityProj = g_saldoFechado + g_lucroAberto;
   
   // 2. Filtro de Notícia (Nativo)
   long segParaNoticia = -1;
   bool noticiaAlta = VerificarNoticiaNativa(segParaNoticia);

   // 3. Checagem de Travas
   CheckSafetyLocks(rates[0].time, noticiaAlta);
   
   // 4. Indicadores
   double smaVal = ObterSMA();
   double acValNow = ObterAC(0);
   double acValPrev = ObterAC(1);

   // 5. Visuais
   double pS = ObjectGetDouble(0, LINHA_SUP, OBJPROP_PRICE);
   double pI = ObjectGetDouble(0, LINHA_INF, OBJPROP_PRICE);
   
   // --- DASHBOARD E TABELA QUANTITATIVA ---
   bool filtroAC_Ok = (acValNow > acValPrev); 
   AtualizarInterfaceMaster(smaVal, acValNow, filtroAC_Ok, segParaNoticia);
   AtualizarTabelaQuantificacao(rates);
   GerenciarNuvensMaster(pS, pI);

   // --- LÓGICA DE TRADING ---
   if(g_botLigado && !g_travaSeguranca) {
      // Regra de bloqueio de segundos iniciais
      long diff = (long)TimeCurrent() - (long)rates[0].time;
      if(diff < (long)InpSegundosBloqueio) return;
      
      AtualizarStopH1();
      ExecutarTrading(rates, smaVal, acValNow, acValPrev, pS, pI);
   }
}

//+------------------------------------------------------------------+
//| FUNÇÕES DE VISUALIZAÇÃO (TABELA E DASHBOARD)                     |
//+------------------------------------------------------------------+
void AtualizarTabelaQuantificacao(MqlRates &r[]) {
   g_somaCC=0; g_somaVC=0; g_totalLinhasC=0; g_totalLinhasV=0;
   int x = InpEixoX, y = InpEixoY+130; 
   
   // Cabeçalhos
   CriarLabel("H_METRICA", "MÉTRICA", x, y-15, clrWhite);
   for(int j=0; j<8; j++) {
      CriarLabel("H_VAL"+(string)j, "V-"+(string)j, x+100+j*60, y-15, (j==0?clrWhite:clrGray));
   }
   CriarLabel("H_RES", "RESULTADO", x+600, y-15, clrWhite);

   string lb[] = {"MAXIMA","ABERTURA","MINIMA","FECHAM.","H-OPEN","OPEN-L","H-CLOSE","CLOSE-L"};
   
   for(int i=0; i<8; i++) {
      CriarLabel("T_N"+(string)i, lb[i], x, y+(i*18), clrYellow);
      
      double vA = ObterValor(i, 0, r); 
      int cC=0, vC=0;
      
      // Quantificação
      for(int k=1; k<=3; k++) { 
         double vK = ObterValor(i, k, r);
         if(vA > vK) cC++; 
         else if(vA < vK) vC++; 
      }
      
      if(i==5||i==6){ int t=vC; vC=cC; cC=t; } // Inversão para métricas de baixa
      
      // Contabilização de Pontos
      if(i!=2 && i!=3) {
         g_somaCC+=cC; g_somaVC+=vC; 
         if(cC>vC) g_totalLinhasC++; else if(vC>cC) g_totalLinhasV++;
         
         string sRes = (cC>vC?"BUY ("+(string)cC+")":(vC>cC?"SELL ("+(string)vC+")":"--"));
         color corRes = (cC>vC?clrLime:(vC>cC?clrRed:clrGray));
         CriarLabel("T_RES"+(string)i, sRes, x+600, y+(i*18), corRes);
      }
      
      // Histórico Visual
      for(int j=0; j<8; j++) {
         string valStr = DoubleToString(ObterValor(i, j, r), _Digits);
         CriarLabel("T_V"+(string)i+(string)j, valStr, x+100+j*60, y+(i*18), (j==0?clrWhite:clrGray));
      }
   }
}

void AtualizarInterfaceMaster(double sma, double ac, bool acUp, long sNot) {
   int x = InpEixoX, y = InpEixoY;
   color corStatus = g_travaSeguranca ? clrOrange : (g_botLigado ? clrLime : clrRed);
   string txtStatus = g_travaSeguranca ? "LIMITE ATINGIDO" : (g_botLigado ? "ATIVO" : "MODO NOTÍCIA");

   CriarLabel("STATUS_BOX", txtStatus + " | OPS: "+(string)g_opsGeral+"/"+(string)InpMaxOperacoes, x, y, corStatus, true);
   
   string txtTimer = "SEM EVENTOS (3*)"; 
   color corTimer = clrCyan;
   if(sNot != -1) {
       txtTimer = StringFormat("NOTÍCIA EM: %02d:%02d:%02d", sNot/3600, (sNot%3600)/60, sNot%60);
       if(sNot < 300) corTimer = clrRed;
   }
   CriarLabel("L_TIMER", txtTimer, x+220, y+8, corTimer);

   CriarLabel("L_INFO", "ATIVO: "+_Symbol+" | LOTE: "+DoubleToString(g_loteFinal, 2), x+5, y+32, clrYellow);
   CriarLabel("L_SMA", "TENDÊNCIA SMA 10: " + (SymbolInfoDouble(_Symbol, SYMBOL_BID)>sma?"ALTA":"BAIXA"), x, y+48, (SymbolInfoDouble(_Symbol, SYMBOL_BID)>sma?clrLime:clrRed));
   CriarLabel("L_PONTOS", StringFormat("PONTOS C: %d | PONTOS V: %d", g_somaCC, g_somaVC), x, y+64, clrWhite);
   CriarLabel("L_FIN", StringFormat("REAL EQUITY: %.2f | LUCRO ABERTO: %.2f", g_equityProj, g_lucroAberto), x, y+80, clrWhite);
   CriarLabel("L_RES", StringFormat("SALDO FECHADO: %.2f", g_saldoFechado), x, y+96, (g_saldoFechado>=0?clrLime:clrRed));
}

//+------------------------------------------------------------------+
//| LÓGICA DE TRADING                                                |
//+------------------------------------------------------------------+
void ExecutarTrading(MqlRates &r[], double sma, double acNow, double acPrev, double pS, double pI) {
   if(AccountInfoDouble(ACCOUNT_MARGIN_FREE) < (g_loteFinal * 100)) return; 

   bool temPos = PositionSelect(_Symbol);
   ulong ticket = temPos ? PositionGetInteger(POSITION_TICKET) : 0;
   
   double mCanal = MathAbs(pS - pI) * 0.20;
   double protSup = pS - mCanal; 
   double protInf = pI + mCanal;
   double preco = r[0].close; 
   double range = r[1].high - r[1].low;

   if(temPos) {
      double lucroPos = PositionGetDouble(POSITION_PROFIT) + PositionGetDouble(POSITION_SWAP);
      bool sairCompra = (PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_BUY && (g_somaVC >= 5 || preco >= protSup));
      bool sairVenda  = (PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_SELL && (g_somaCC >= 5 || preco <= protInf));
      
      if((sairCompra || sairVenda) && lucroPos > 0) { 
         trade.PositionClose(ticket); 
         ContabilizarOp(); 
      }
      return; 
   }

   if((int)SymbolInfoInteger(_Symbol, SYMBOL_SPREAD) > InpMaxSpread) return; 
   
   bool consensoCompra = (g_totalLinhasC == 6); 
   bool consensoVenda  = (g_totalLinhasV == 6);
   bool sinalAC_Compra = (!InpUsarAC || (acNow > acPrev && acNow > 0));
   bool sinalAC_Venda  = (!InpUsarAC || (acNow < acPrev && acNow < 0));
   // double romp = range * InpPercentualRomp; // Removido se não for usado ou usado explicitamente
   double romp = range * InpPercentualRomp;
   
   if(consensoCompra && sinalAC_Compra && preco > sma && preco > (r[1].high + romp) && preco < protSup) {
      double slH1 = CalcularStopH1(POSITION_TYPE_BUY);
      if(trade.Buy(g_loteFinal, _Symbol, SymbolInfoDouble(_Symbol, SYMBOL_ASK), slH1, 0, "Jobot1 Buy")) ContabilizarOp();
   }
   else if(consensoVenda && sinalAC_Venda && preco < sma && preco < (r[1].low - romp) && preco > protInf) {
      double slH1 = CalcularStopH1(POSITION_TYPE_SELL);
      if(trade.Sell(g_loteFinal, _Symbol, SymbolInfoDouble(_Symbol, SYMBOL_BID), slH1, 0, "Jobot1 Sell")) ContabilizarOp();
   }
}

//+------------------------------------------------------------------+
//| UTILS (Cálculos e Helpers)                                       |
//+------------------------------------------------------------------+
void CheckSafetyLocks(datetime currentTime, bool newsActive) {
   if(!g_travaSeguranca && (g_equityProj >= (InpMetaFinanceira*2) || g_equityProj <= -InpDrawdownMax || g_opsGeral >= InpMaxOperacoes)) 
      g_travaSeguranca = true; 
      
   if(newsActive) g_botLigado = false; 
   else if(!g_travaSeguranca) g_botLigado = true;
}

bool VerificarNoticiaNativa(long &segundosRestantes) {
   MqlCalendarValue values[];
   datetime inicio = TimeCurrent() - (InpMinAntes * 60); 
   datetime fim = TimeCurrent() + (InpMinDepois * 60);
   string baseCurr = SymbolInfoString(_Symbol, SYMBOL_CURRENCY_BASE);
   string profitCurr = SymbolInfoString(_Symbol, SYMBOL_CURRENCY_PROFIT);
   
   if(CalendarValueGet(values, inicio, fim, baseCurr)>0 || CalendarValueGet(values, inicio, fim, profitCurr)>0 || CalendarValueGet(values, inicio, fim, "USD")>0) {
      for(int i=0; i<ArraySize(values); i++) {
         MqlCalendarEvent ev; 
         CalendarEventById(values[i].event_id, ev);
         if(ev.importance == CALENDAR_IMPORTANCE_HIGH) { 
            segundosRestantes = (long)values[i].time - (long)TimeCurrent(); 
            return true; 
         }
      }
   }
   return false;
}

double CalcularStopH1(long tipo) {
   MqlRates r[]; 
   ArraySetAsSeries(r, true);
   if(CopyRates(_Symbol, PERIOD_H1, 1, 1, r) <= 0) return 0;
   
   double range = (r[0].high - r[0].low) * 0.5;
   return (tipo == POSITION_TYPE_BUY) ? NormalizeDouble(r[0].low - range, _Digits) : NormalizeDouble(r[0].high + range, _Digits);
}

void AtualizarStopH1() {
   if(PositionSelect(_Symbol) && PositionGetInteger(POSITION_MAGIC) == 999888) { 
      double nSL = CalcularStopH1(PositionGetInteger(POSITION_TYPE));
      double currSL = PositionGetDouble(POSITION_SL);
      if(nSL > 0 && MathAbs(nSL - currSL) > _Point) {
         trade.PositionModify(PositionGetInteger(POSITION_TICKET), nSL, 0);
      }
   }
}

void ConfigurarLinhasMaster(double r, double s) { 
   if(ObjectFind(0,LINHA_SUP)<0) ObjectCreate(0,LINHA_SUP,OBJ_HLINE,0,0,r); 
   if(ObjectFind(0,LINHA_INF)<0) ObjectCreate(0,LINHA_INF,OBJ_HLINE,0,0,s);
   ObjectSetInteger(0,LINHA_SUP,OBJPROP_COLOR,clrDeepSkyBlue); ObjectSetInteger(0,LINHA_SUP,OBJPROP_WIDTH,2);
   ObjectSetInteger(0,LINHA_INF,OBJPROP_COLOR,clrOrangeRed);   ObjectSetInteger(0,LINHA_INF,OBJPROP_WIDTH,2);
}

void GerenciarNuvensMaster(double pS, double pI) { 
   double m = MathAbs(pS - pI) * 0.20; 
   color cD = clrDimGray; // Standard color substitute
   DesenharNuvemMaster("Z1", pS, pS-m, cD); 
   DesenharNuvemMaster("Z2", pI, pI+m, cD);
}

void DesenharNuvemMaster(string n, double p1, double p2, color c) { 
   string nm = PREFIX_V+n; 
   if(ObjectFind(0,nm)<0) { 
      ObjectCreate(0,nm,OBJ_RECTANGLE,0,0,p1,0,p2); 
      ObjectSetInteger(0,nm,OBJPROP_FILL,true); 
      ObjectSetInteger(0,nm,OBJPROP_BACK,true); 
   }
   ObjectSetDouble(0,nm,OBJPROP_PRICE,0,p1); 
   ObjectSetDouble(0,nm,OBJPROP_PRICE,1,p2); 
   ObjectSetInteger(0,nm,OBJPROP_COLOR,c); 
   ObjectSetInteger(0,nm,OBJPROP_TIME,1,TimeCurrent()+3600*12);
}

void CriarLabel(string n, string t, int x, int y, color c, bool btn=false) { 
   string nm = PREFIX_V+n; 
   if(ObjectFind(0,nm)<0) { 
      ObjectCreate(0,nm,btn?OBJ_BUTTON:OBJ_LABEL,0,0,0); 
      if(btn){ 
         ObjectSetInteger(0,nm,OBJPROP_XSIZE,220); 
         ObjectSetInteger(0,nm,OBJPROP_YSIZE,30); 
      }
   }
   ObjectSetString(0,nm,OBJPROP_TEXT,t); 
   ObjectSetInteger(0,nm,OBJPROP_XDISTANCE,x); 
   ObjectSetInteger(0,nm,OBJPROP_YDISTANCE,y); 
   ObjectSetInteger(0,nm,OBJPROP_COLOR,c); 
   ObjectSetInteger(0,nm,OBJPROP_FONTSIZE,InpTamanhoFonte);
}

void ContabilizarOp() { 
   g_opsGeral++; 
   GlobalVariableSet(g_gvName, g_opsGeral); 
}

void CalcularFinanceiroGeral() { 
   g_lucroAberto = (PositionSelect(_Symbol)) ? PositionGetDouble(POSITION_PROFIT) : 0; 
   HistorySelect(g_horaInicioSessao, TimeCurrent()); 
   g_saldoFechado=0; 
   for(int i=0; i<HistoryDealsTotal(); i++){ 
      ulong tk=HistoryDealGetTicket(i); 
      if(HistoryDealGetInteger(tk,DEAL_MAGIC)==999888) 
         g_saldoFechado+=HistoryDealGetDouble(tk,DEAL_PROFIT);
   } 
}

void LimparGrafico() { 
   ObjectsDeleteAll(0, PREFIX_V); 
   ObjectDelete(0, LINHA_SUP); 
   ObjectDelete(0, LINHA_INF); 
   ChartRedraw(); 
}

double ObterValor(int l, int idx, MqlRates &r[]) { 
   switch(l) { 
      case 0: return r[idx].high; 
      case 1: return r[idx].open; 
      case 2: return r[idx].low; 
      case 3: return r[idx].close; 
      case 4: return r[idx].high - r[idx].open; 
      case 5: return r[idx].open - r[idx].low; 
      case 6: return r[idx].high - r[idx].close; 
      case 7: return r[idx].close - r[idx].low;
   } 
   return 0; 
}

double ObterSMA() { 
   double b[]; 
   ArraySetAsSeries(b,true); 
   return (CopyBuffer(handleSMA,0,0,1,b)>0) ? b[0] : 0; 
}

double ObterAC(int i) { 
   double b[]; 
   ArraySetAsSeries(b,true); 
   return (CopyBuffer(handleAC,0,i,1,b)>0) ? b[0] : 0; 
}
