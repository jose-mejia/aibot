//+------------------------------------------------------------------+
//|                                              jobot2_restored.mq5 |
//|                                     Copyright 2025, Gemini Agent |
//|                    SUPORTE E RESISTÊNCIA (Lógica Mínima Estável) |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Gemini Agent"
#property version   "1.01"
#property strict

#include <Trade\Trade.mqh>

//--- INPUTS ---
input group "--- SUPORTE E RESISTÊNCIA ---"
input double      InpMargemPercent    = 0.20;       // % Margem de Proteção (Canal)
input color       InpCorSuporte       = clrOrangeRed;
input color       InpCorResistencia   = clrDeepSkyBlue;
input color       InpCorMargem        = clrDimGray;

input group "--- GESTÃO ---"
input double      InpVolume           = 0.01;
input int         InpSlippage         = 30;

//--- GLOBAIS ---
CTrade          trade;
const string    LINHA_SUP = "TH_L_SUP";
const string    LINHA_INF = "TH_L_INF";
const string    PREFIX_V  = "TH_V_";

//+------------------------------------------------------------------+
//| Inicialização (OnInit)                                           |
//+------------------------------------------------------------------+
int OnInit() {
   trade.SetExpertMagicNumber(999777); // Magic específico Jobot2
   trade.SetDeviationInPoints(InpSlippage);

   // Carrega dados DIÁRIOS para marcar S/R
   // Usa DIA ANTERIOR (Índice 1) para garantir níveis estáveis
   MqlRates daily[]; 
   ArraySetAsSeries(daily, true);
   
   if(CopyRates(_Symbol, PERIOD_D1, 0, 2, daily) > 1) { 
      // Define linhas com base no High/Low de ONTEM
      ConfigurarLinhasMaster(daily[1].high, daily[1].low);
   } else {
      Print("Erro ao obter dados D1. Tentando novamente no próximo tick.");
   }
   
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Desinicialização (OnDeinit)                                      |
//+------------------------------------------------------------------+
void OnDeinit(const int reason) { 
   LimparGrafico(); 
}

//+------------------------------------------------------------------+
//| Loop Principal (OnTick)                                          |
//+------------------------------------------------------------------+
void OnTick() {
   // 1. Obter posição das linhas (S/R)
   if(ObjectFind(0, LINHA_SUP) < 0 || ObjectFind(0, LINHA_INF) < 0) {
       // Se linhas sumiram, recria baseado em dados atuais (Fallback)
       MqlRates daily[]; 
       ArraySetAsSeries(daily, true);
       if(CopyRates(_Symbol, PERIOD_D1, 0, 2, daily) > 1) { 
          ConfigurarLinhasMaster(daily[1].high, daily[1].low);
       }
       return;
   }

   double pS = ObjectGetDouble(0, LINHA_SUP, OBJPROP_PRICE);
   double pI = ObjectGetDouble(0, LINHA_INF, OBJPROP_PRICE);
   
   // 2. Atualizar Nuvens (Margens Visuais)
   GerenciarNuvensMaster(pS, pI);

   // 3. Validação de Margens (Lógica Principal)
   double mCanal = MathAbs(pS - pI) * InpMargemPercent;
   double protSup = pS - mCanal; // Teto (Não comprar acima disso)
   double protInf = pI + mCanal; // Piso (Não vender abaixo disso)
   
   // Verifica se o preço atual permite operações
   ValidarOperacoes(protSup, protInf);
}

//+------------------------------------------------------------------+
//| LÓGICA DE VALIDAÇÃO (S/R)                                        |
//+------------------------------------------------------------------+
void ValidarOperacoes(double protSup, double protInf) {
   double close = iClose(_Symbol, _Period, 0);

   // Regras de Segurança (Extraídas de jobot1):
   // - Zona de "Canal": Entre protInf e protSup.
   // - Compra Segura: Preço < protSup (Ainda tem espaço para subir até a resistência)
   // - Venda Segura:  Preço > protInf (Ainda tem espaço para cair até o suporte)
   
   bool zonaCompraSegura = (close < protSup);
   bool zonaVendaSegura  = (close > protInf);

   string msg = StringFormat(
      "Jobot2 (S/R Stable)\n-------------------\nResistência (Ontem): %.5f\nSuporte (Ontem): %.5f\n\n[Margens de Proteção]\nTeto Compra: %.5f\nPiso Venda:  %.5f\n\n[Validação Atual]\nPode Comprar? %s\nPode Vender?  %s",
      ObjectGetDouble(0, LINHA_SUP, OBJPROP_PRICE),
      ObjectGetDouble(0, LINHA_INF, OBJPROP_PRICE),
      protSup,
      protInf,
      zonaCompraSegura ? "SIM (Dentro do Canal)" : "NÃO (Perto da Resistência)",
      zonaVendaSegura  ? "SIM (Dentro do Canal)" : "NÃO (Perto do Suporte)"
   );
   
   Comment(msg);
   
   // NOTA: Para executar ordens automaticamente, adicione gatilhos aqui.
   // Exemplo: if(zonaCompraSegura && SinalDeEntrada...) { Trade.Buy... }
}

//+------------------------------------------------------------------+
//| FUNÇÕES VISUAIS                                                  |
//+------------------------------------------------------------------+
void ConfigurarLinhasMaster(double r, double s) { 
   if(ObjectFind(0,LINHA_SUP)<0) ObjectCreate(0,LINHA_SUP,OBJ_HLINE,0,0,r); 
   if(ObjectFind(0,LINHA_INF)<0) ObjectCreate(0,LINHA_INF,OBJ_HLINE,0,0,s);
   
   // Força atualização de propriedades em cada chamada
   ObjectSetDouble(0,LINHA_SUP, OBJPROP_PRICE, r);
   ObjectSetDouble(0,LINHA_INF, OBJPROP_PRICE, s);
   
   ObjectSetInteger(0,LINHA_SUP,OBJPROP_COLOR,InpCorResistencia); 
   ObjectSetInteger(0,LINHA_SUP,OBJPROP_WIDTH,2);
   ObjectSetInteger(0,LINHA_INF,OBJPROP_COLOR,InpCorSuporte);     
   ObjectSetInteger(0,LINHA_INF,OBJPROP_WIDTH,2);
}

void GerenciarNuvensMaster(double pS, double pI) { 
   double m = MathAbs(pS - pI) * InpMargemPercent; 
   DesenharNuvemMaster("Z1_RES", pS, pS-m, InpCorMargem); 
   DesenharNuvemMaster("Z2_SUP", pI, pI+m, InpCorMargem);
}

void DesenharNuvemMaster(string n, double p1, double p2, color c) { 
   string nm = PREFIX_V+n; 
   
   // Cria o objeto se não existir
   if(ObjectFind(0,nm)<0) { 
      // Time1 e Time2 definem a largura do retângulo no tempo.
      // Usamos TimeCurrent para garantir visibilidade.
      ObjectCreate(0,nm,OBJ_RECTANGLE,0,0,TimeCurrent(),p1,TimeCurrent()+PERIOD_D1*60,p2); 
      ObjectSetInteger(0,nm,OBJPROP_FILL,true); 
      ObjectSetInteger(0,nm,OBJPROP_BACK,true); 
   }
   
   // Atualiza Posição (Move o retângulo para acompanhar o tempo)
   // Time1 = Agora - X barras (para ver histórico recente)
   // Time2 = Agora + 1 Dia (para ver projeção futura)
   ObjectSetInteger(0,nm,OBJPROP_TIME,0,TimeCurrent() - PeriodSeconds()*10); 
   ObjectSetInteger(0,nm,OBJPROP_TIME,1,TimeCurrent() + PeriodSeconds()*1440);
   
   ObjectSetDouble(0,nm,OBJPROP_PRICE,0,p1); 
   ObjectSetDouble(0,nm,OBJPROP_PRICE,1,p2); 
   ObjectSetInteger(0,nm,OBJPROP_COLOR,c); 
}

void LimparGrafico() { 
   ObjectsDeleteAll(0, PREFIX_V); 
   ObjectDelete(0, LINHA_SUP); 
   ObjectDelete(0, LINHA_INF); 
   Comment(""); 
   ChartRedraw(); 
}
