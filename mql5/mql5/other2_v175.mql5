//+------------------------------------------------------------------+
//|                                   TraderHelper_EA_ESTAVEL_V35.mq5|
//|                                   Copyright 2025, Gemini AI Bot  |
//|      VERSÃO 1.75: Proteção 4s + News Filter + Lógica Estável     |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Gemini AI Bot"
#property version   "1.75"
#property strict

#include <Trade\Trade.mqh>
#include <Trade\PositionInfo.mqh>

//--- Parâmetros de Entrada
input int      InpTamanhoFonte    = 8;          
input double   InpVolume          = 0.01;       
input int      InpMagicNumber     = 123456;
input int      InpSegundosBloqueio = 4;      // Bloqueio nos primeiros 4s da vela
input int      InpMinutosNoticia   = 5;      // Bloqueio 5min antes e depois

//--- Variáveis Globais
datetime ultima_vela = 0;
CTrade   trade;
CPositionInfo posInfo;

//--- Inicialização
int OnInit() {
   trade.SetExpertMagicNumber(InpMagicNumber);
   EventSetTimer(1);
   Print("EA Iniciado - Versão 1.75 com Filtros Ativos");
   return(INIT_SUCCEEDED);
}

//--- Desinicialização
void OnDeinit(const int reason) {
   EventKillTimer();
   LimparGrafico();
}

//--- Processamento Principal
void OnTick() {
   MqlRates rates[];
   ArraySetAsSeries(rates, true);
   if(CopyRates(_Symbol, _Period, 0, 10, rates) < 10) return;

   if(rates[0].time != ultima_vela) {
      ultima_vela = rates[0].time;
   }

   // --- FILTRO 1: SEGUNDOS INICIAIS DA VELA ---
   datetime horaAtual = TimeCurrent();
   long segundosDecorridos = (long)horaAtual - (long)rates[0].time;
   
   // --- FILTRO 2: CALENDÁRIO DE NOTÍCIAS ---
   long segundosParaNoticia = -1;
   bool noticiaPerto = VerificarNoticia(segundosParaNoticia);

   // Atualiza os Timers no Gráfico
   AtualizarVisualNoticia(segundosParaNoticia);

   // --- LÓGICA DE PERMISSÃO ---
   bool podeOperar = true;
   string msgStatus = "OPERACIONAL";
   color corStatus = clrLime;

   if(segundosDecorridos < InpSegundosBloqueio) {
      podeOperar = false;
      msgStatus = "AGUARDANDO ABERTURA (" + (string)(InpSegundosBloqueio - segundosDecorridos) + "s)";
      corStatus = clrYellow;
   }
   else if(noticiaPerto) {
      podeOperar = false;
      msgStatus = "BLOQUEADO: NOTÍCIA ALTO IMPACTO";
      corStatus = clrOrange;
   }

   CriarLabelTab("FiltroStatus", "SISTEMA: " + msgStatus, 15, 35, corStatus);

   // --- CÁLCULO DA PONTUAÇÃO (ESTÁVEL) ---
   int pontosC = 0;
   int pontosV = 0;
   AtualizarTabelaCronologica(rates, pontosC, pontosV);
   
   // --- GESTÃO DE ORDENS ---
   ActualizarStopH1();
   if(podeOperar) {
      GerenciarOrdens(pontosC, pontosV);
   }
}

//--- Verificação de Notícias 3 Estrelas (MQL5 Nativo)
bool VerificarNoticia(long &segundosRestantes) {
   MqlCalendarValue values[];
   datetime inicio = TimeCurrent() - (InpMinutosNoticia * 60);
   datetime fim    = TimeCurrent() + (InpMinutosNoticia * 60);
   
   if(CalendarValueGet(values, inicio, fim, _Symbol) > 0 || CalendarValueGet(values, inicio, fim, "USD") > 0) {
      for(int i=0; i<ArraySize(values); i++) {
         MqlCalendarEvent ev;
         CalendarEventById(values[i].event_id, ev);
         if(ev.importance == CALENDAR_IMPORTANCE_HIGH) {
            segundosRestantes = (long)values[i].time - (long)TimeCurrent();
            return true;
         }
      }
   }
   return false;
}

//--- Gestor de Ordens (Apenas se passar nos filtros)
void GerenciarOrdens(int pC, int pV) {
   if(pC == pV) return;

   bool temCompra = false, temVenda = false;
   ulong ticket = 0;

   if(PositionSelect(_Symbol)) {
      if(PositionGetInteger(POSITION_MAGIC) == InpMagicNumber) {
         ticket = PositionGetInteger(POSITION_TICKET);
         if(PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY) temCompra = true;
         else temVenda = true;
      }
   }

   if(pC > pV) { // Tendência de Compra
      if(temVenda) trade.PositionClose(ticket);
      if(!temCompra) {
         double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
         double sl = CalcularStopH1(POSITION_TYPE_BUY);
         trade.Buy(InpVolume, _Symbol, ask, sl, 0, "Compra via Pontuação");
      }
   }
   else if(pV > pC) { // Tendência de Venda
      if(temCompra) trade.PositionClose(ticket);
      if(!temVenda) {
         double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
         double sl = CalcularStopH1(POSITION_TYPE_SELL);
         trade.Sell(InpVolume, _Symbol, bid, sl, 0, "Venda via Pontuação");
      }
   }
}

//--- Tabela Visual e Pontuação Rigorosa
void AtualizarTabelaCronologica(MqlRates &rates[], int &outC, int &outV) {
   int xStart = 15, yStart = 85, vStep = 18, hStep = 80;
   int colV = xStart + 70 + (8 * hStep);
   int colC = colV + 35;
   int colR = colC + 45;
   outC = 0; outV = 0;

   for(int i=0; i<8; i++) {
      int vCount = 0, cCount = 0;
      double v1 = ObterValorPorLinha(i, 0, rates);

      for(int k=1; k<=3; k++) {
         double vK = ObterValorPorLinha(i, k, rates);
         if(v1 > vK) cCount++; else if(v1 < vK) vCount++;
      }

      // Regra Especial Linha 6 (i=5) e Linha 7 (i=6): Menor = Compra
      if(i == 5 || i == 6) {
         int temp = vCount; vCount = cCount; cCount = temp;
      }

      if(!(i == 2 || i == 3)) { // Ignora Low/Close simples para o resultado final
         string res = "---"; color cor = clrWhite;
         if(cCount > vCount) { res = "COMPRA"; cor = clrLime; outC++; }
         else if(vCount > cCount) { res = "VENDA"; cor = clrRed; outV++; }

         CriarLabelTab("Res"+(string)i, res, colR, yStart + (i*vStep), cor);
         CriarLabelTab("VC"+(string)i, (string)vCount, colV, yStart + (i*vStep), clrRed);
         CriarLabelTab("CC"+(string)i, (string)cCount, colC, yStart + (i*vStep), clrLime);
      }

      // Valores Históricos (V1 a V8)
      for(int j=1; j<=8; j++) {
         double val = ObterValorPorLinha(i, 8-j, rates);
         CriarLabelTab("V"+(string)i+(string)j, DoubleToString(val, _Digits), xStart+70+(j-1)*hStep, yStart+(i*vStep), (j==8?clrWhite:clrGray));
      }
   }
}

//--- Funções de Suporte (Stop, Visual, News)
double CalcularStopH1(long tipo) {
   MqlRates r[]; ArraySetAsSeries(r, true);
   if(CopyRates(_Symbol, PERIOD_H1, 1, 1, r) <= 0) return 0;
   double d = (r[0].high - r[0].low) * 0.5;
   return (tipo == POSITION_TYPE_BUY) ? NormalizeDouble(r[0].low - d, _Digits) : NormalizeDouble(r[0].high + d, _Digits);
}

void ActualizarStopH1() {
   if(PositionSelect(_Symbol) && PositionGetInteger(POSITION_MAGIC) == InpMagicNumber) {
      double nSL = CalcularStopH1(PositionGetInteger(POSITION_TYPE));
      if(nSL > 0 && MathAbs(nSL - PositionGetDouble(POSITION_SL)) > _Point)
         trade.PositionModify(PositionGetInteger(POSITION_TICKET), nSL, 0);
   }
}

void AtualizarVisualNoticia(long segundos) {
   string txt = "PRÓX. NOTÍCIA: BUSCANDO..."; color cor = clrGray;
   if(segundos != -1) {
      txt = StringFormat("PRÓX. NOTÍCIA (3*): %02d:%02d:%02d", segundos/3600, (segundos%3600)/60, segundos%60);
      cor = (segundos < 300) ? clrRed : clrCyan;
   }
   int x = (int)ChartGetInteger(0, CHART_WIDTH_IN_PIXELS) - 260;
   int y = (int)ChartGetInteger(0, CHART_HEIGHT_IN_PIXELS) - 35;
   CriarLabelTab("TimerNews", txt, x, y, cor);
}

double ObterValorPorLinha(int l, int idx, MqlRates &r[]) {
   switch(l) {
      case 0: return r[idx].high;  case 1: return r[idx].open;
      case 2: return r[idx].low;   case 3: return r[idx].close;
      case 4: return r[idx].high - r[idx].open;
      case 5: return r[idx].open - r[idx].low;
      case 6: return r[idx].high - r[idx].close;
      case 7: return r[idx].close - r[idx].low;
   }
   return 0;
}

void CriarLabelTab(string n, string t, int x, int y, color c) {
   if(ObjectFind(0, n) < 0) {
      ObjectCreate(0, n, OBJ_LABEL, 0, 0, 0);
      ObjectSetInteger(0, n, OBJPROP_FONTSIZE, InpTamanhoFonte);
      ObjectSetString(0, n, OBJPROP_FONT, "Courier New");
   }
   ObjectSetString(0, n, OBJPROP_TEXT, t);
   ObjectSetInteger(0, n, OBJPROP_XDISTANCE, x);
   ObjectSetInteger(0, n, OBJPROP_YDISTANCE, y);
   ObjectSetInteger(0, n, OBJPROP_COLOR, c);
}

void LimparGrafico() {
   ObjectsDeleteAll(0, "V"); ObjectsDeleteAll(0, "Res"); ObjectsDeleteAll(0, "CC"); ObjectsDeleteAll(0, "VC");
   ObjectDelete(0, "FiltroStatus"); ObjectDelete(0, "TimerNews"); ChartRedraw();
}
